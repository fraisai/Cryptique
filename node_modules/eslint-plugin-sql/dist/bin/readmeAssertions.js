"use strict";
/**
 * @file This script is used to inline assertions into the README.md documents.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const glob_1 = __importDefault(require("glob"));
const lodash_1 = __importDefault(require("lodash"));
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const formatCodeSnippet = (setup) => {
    const paragraphs = [];
    paragraphs.push(setup.code);
    if (setup.options) {
        paragraphs.push('// Options: ' + JSON.stringify(setup.options));
    }
    if (setup.errors) {
        for (const message of setup.errors) {
            paragraphs.push('// Message: ' + message.message);
        }
    }
    if (setup.output) {
        paragraphs.push('// Fixed code: \n// ' + setup.output.split('\n').join('\n// '));
    }
    return paragraphs.join('\n');
};
const getAssertions = () => {
    const assertionFiles = glob_1.default.sync(node_path_1.default.resolve(__dirname, '../test/rules/assertions/*.ts'));
    const assertionNames = lodash_1.default.map(assertionFiles, (filePath) => {
        return node_path_1.default.basename(filePath, '.ts');
    });
    const assertionCodes = lodash_1.default.map(assertionFiles, (filePath) => {
        // eslint-disable-next-line node/global-require, @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        const codes = require(filePath);
        return {
            invalid: lodash_1.default.map(codes.invalid, formatCodeSnippet),
            valid: lodash_1.default.map(codes.valid, formatCodeSnippet),
        };
    });
    return lodash_1.default.zipObject(assertionNames, assertionCodes);
};
const updateDocuments = (assertions) => {
    const readmeDocumentPath = node_path_1.default.join(__dirname, '../README.md');
    let documentBody = node_fs_1.default.readFileSync(readmeDocumentPath, 'utf8');
    documentBody = documentBody.replaceAll(/<!-- assertions ([a-z]+) -->/giu, (assertionsBlock) => {
        var _a;
        let exampleBody = '';
        const ruleName = (_a = /assertions ([a-z]+)/iu.exec(assertionsBlock)) === null || _a === void 0 ? void 0 : _a[1];
        if (!ruleName) {
            throw new Error('Rule name not found.');
        }
        const ruleAssertions = assertions[ruleName];
        if (!ruleAssertions) {
            throw new Error('No assertions available for rule "' + ruleName + '".');
        }
        if (ruleAssertions.invalid.length) {
            exampleBody +=
                'The following patterns are considered problems:\n\n```js\n' +
                    ruleAssertions.invalid.join('\n\n') +
                    '\n```\n\n';
        }
        if (ruleAssertions.valid.length) {
            exampleBody +=
                'The following patterns are not considered problems:\n\n```js\n' +
                    ruleAssertions.valid.join('\n\n') +
                    '\n```\n\n';
        }
        return exampleBody;
    });
    node_fs_1.default.writeFileSync(readmeDocumentPath, documentBody);
};
updateDocuments(getAssertions());
